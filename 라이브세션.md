| **범주**                                                     | **대표 개념/도구**                                           | **설명**                                                     |
| ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| **동시성 제어 (Concurrency Control)**                        | synchronized, Lock, ReentrantLock, AtomicXXX, Semaphore, StampedLock | 여러 스레드가 **공유 자원에 안전하게 접근**하도록 보장하는 제어 방식. |
| **흐름 제어 / 비동기 흐름 관리 (Flow Control / Asynchronous Flow)** | Future, CompletableFuture, Reactive Streams, Flow API, Mono/Flux (Project Reactor), Coroutine, Virtualthread | 작업의 **실행 순서**나 **응답 흐름**을 관리하는 방식. 주로 **비동기 처리**와 관련된다. |

## **🔹 흐름 제어 (Flow / Asynchronous Control)**

- 목적: **작업 간 순서와 응답의 흐름을 관리**
- 주요 키워드:
  - Future, CompletableFuture: 비동기 작업 결과 처리
  - Flow API (Java 9): Reactive Streams 표준
  - Project Reactor, RxJava: 반응형 스트림 구현체
  - Coroutine (Kotlin): 비동기 흐름을 마치 동기처럼 표현

> 💡 “언제 어떤 순서로 처리되고 응답을 받을지”를 제어

![image-20250806204114928](../Library/Application%20Support/typora-user-images/image-20250806204114928.png)

--

✅ 1. 스레드란?
	•	프로세스 내에서 실행 흐름의 단위
	•	하나의 프로세스 안에 여러 스레드가 존재할 수 있으며, 메모리 공간(코드, 힙 등)을 공유함
	•	스레드는 병렬 처리나 논리적 동시성 구현에 사용됨

운영체제 관점에서 

스레드는 **OS가 인식하는 단위인 커널 스레드**와 **프로그래머가 유저 공간에서 만들 수 있는 유저 스레드**로 나눔

```java
Thread t = new Thread(() -> {
            for (int i = 0; i < 100000; i++) {
                counter.addWithLock(1);
            }
});

t.start();
t.join();

```

**✅ 1. Thread.start() 호출 시**

🧠 JVM 레벨
	•	새로운 Thread 인스턴스를 통해 JVM 스레드 객체를 생성하고,
	•	이 객체에 바인딩된 Runnable 코드 블록을 실행하도록 준비함
	•	이후 JVM은 **OS에게 새 스레드 생성을 요청**함

🖥️ 운영체제(OS) 레벨
	•	OS는 **새 커널 스레드(플랫폼 스레드)**를 생성(Java의 기본 스레드는 OS 쓰레드에 1:1 매핑됨)
	•	이 스레드는 독립된 콜 스택과 레지스터 세트를 가짐
	•	스케줄러가 CPU 코어 중 하나에 이 스레드를 배정하여 실행 시작
	•	이 스레드는 병렬 또는 병행적으로 동작할 수 있음 (멀티코어 환경)



**✅ 2.Thread.join() 호출 시**

**🧠 JVM 레벨**

- 현재 스레드 (예: main 스레드)는 t.join() 호출 시,

  내부적으로 **모니터 락과 condition variable**을 사용하여

  스레드가 **끝날 때까지 블로킹됨**

- 즉, join()을 호출한 스레드는 **WAITING 상태로 전환**

**🖥️ 운영체제(OS) 레벨**

- OS는 main 스레드에 대해 **park() 또는 wait syscall** 을 걸어두고,

  해당 스레드를 **스케줄링에서 제외**함

- t 스레드가 끝나면 OS와 JVM은 main 스레드를 **UNPARK / wake up** 처리



**🔁 실행 순서 시퀀스**
	1.	main() → t.start() 호출
	2.	JVM → OS에게 스레드 생성 요청
	3.	OS → 커널 스레드 생성, 작업 실행
	4.	main() → t.join() 호출 → WAITING 상태 진입
	5.	t 스레드 → 작업 완료
	6.	JVM → main() 스레드 UNBLOCK → 다시 실행 재개



기존에는

Thread

- 유저스레드 > 커널스레드 > 유저스레드



Virtual Thread

- 유저스레드 >  유저스레드







- CompletableFuture vs ExecutorService 차이점은?

- Virtual Thread 란?

```java
//JAVA 25 에서 synchronized  동작이 어떻게 변경된걸까?
Thread.ofVirtual().start(() -> {
    synchronized (lock) {
      // Virtual 스레드로 동작
        Thread.sleep(5000); // 블로킹
    }
  // Pinning
});
```

🔍 JVM의 동작 흐름 (Java 21까지)

	1.	Thread.ofVirtual() → JVM은 가상 스레드 객체 생성
	2.	synchronized(lock) → JVM은 ObjectMonitor(모니터 락) 획득
	•	이 락은 JVM 내부적으로는 플랫폼 락 구조로 구현됨
	•	Java 21까지는 이 락을 안전하게 풀고 재진입하는 구조가 아니었음
	3.	Thread.sleep() 또는 블로킹 I/O 호출 발생
	4.	JVM은 이 블로킹 호출을 감지하지만,
	•	synchronized 안에서 실행 중이므로 락 상태를 안전하게 포기할 수 없음
	5.	결과적으로 JVM은 해당 가상 스레드를 플랫폼 스레드에 붙잡은 채(pinned) 실행 유지
	6.	이 플랫폼 스레드는 다른 가상 스레드 작업을 수행할 수 없음





- Java 24 에서 synchronized  동작이 어떻게 변경된걸까?
  - 가상 스레드가 